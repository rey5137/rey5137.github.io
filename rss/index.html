<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Rey Pham]]></title><description><![CDATA[Sofware Developer]]></description><link>http://localhost:2368/</link><image><url>http://localhost:2368/favicon.png</url><title>Rey Pham</title><link>http://localhost:2368/</link></image><generator>Ghost 5.23</generator><lastBuildDate>Thu, 24 Nov 2022 08:58:55 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Power up your REST service with Batch API]]></title><description><![CDATA[A different approach with GraphQL, that can quickly integrate into your REST service without the need to define any schema. ]]></description><link>http://localhost:2368/power_up_rest_service_with_batch_api/</link><guid isPermaLink="false">637f1ad6a0d66a0001cab8f7</guid><category><![CDATA[Java]]></category><category><![CDATA[Batch]]></category><category><![CDATA[JSON]]></category><category><![CDATA[Springboot]]></category><dc:creator><![CDATA[Rey Pham]]></dc:creator><pubDate>Fri, 10 Jul 2020 09:42:30 GMT</pubDate><content:encoded><![CDATA[<p>RESTful APIs is pretty common nowadays, as a clear and well-structured resource-oriented standard. But we often have to face the use case that requires to call multi APIs to collect all the necessary data. This quickly becomes a problem if your client is a mobile device with limited network, and only interested in a subset data of all your API responses.</p><p>A popular solution to this problem is <a href="https://graphql.org/">GraphQL</a>, a query language from Facebook. Although GraphQL is a powerful tool, it still requires you to define all the schemas &amp; functions before the client can use it. In this post, I will show you a different approach, by creating a Batch Request API, that can quickly integrate into your REST service without the need to define any schema. </p><h2 id="the-code">The code</h2><p>For a Batch Request API, we&apos;ll need an Engine that able to build &amp; execute requests sequentially, then collect all responses. For all of the hard part, I will use this <a href="https://github.com/rey5137/jsonbatch"><strong>JsonBatch</strong></a> library, &#xA0;that provides many out-of-box features like: <strong>build &amp; extract JSON object, conditional &amp; looping requests, aggregate functions</strong>, ... You can test out it features <a href="https://jsonbatch-playground.herokuapp.com/sample1">here</a></p><p>Below is the code to setup a Batch Engine :</p><pre><code class="language-Java">@Bean
public BatchEngine getBatchEngine(ObjectMapper objectMapper, RequestDispatcherService dispatcherService) {
    Configuration conf = Configuration.builder()
            .options(Option.SUPPRESS_EXCEPTIONS)
            .jsonProvider(new JacksonJsonProvider(objectMapper))
            .mappingProvider(new JacksonMappingProvider(objectMapper))
            .build();
    JsonBuilder jsonBuilder = new JsonBuilder(Functions.basic());
    return new BatchEngine(conf, jsonBuilder, dispatcherService);
}</code></pre><p>And next is the Controller. The logic is quite simple, we only need to build the original request and pass it to Batch Engine along with batch template. After Batch Engine return response, we just warp it up with ResponseEntity and return.</p><pre><code class="language-Java">@RequestMapping(value = &quot;/batch&quot;, method = RequestMethod.POST, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
public ResponseEntity batchRequests(@RequestHeader MultiValueMap&lt;String, String&gt; headers, @RequestBody BatchRequest batchRequest) {
    Request request = buildOriginalRequest(headers, batchRequest.getData());
    Response response = batchEngine.execute(request, batchRequest.getTemplate());
    return new ResponseEntity(response.getBody(), HttpStatus.resolve(response.getStatus()));
    return responseEntity;
}

private Request buildOriginalRequest(MultiValueMap&lt;String, String&gt; headers, Object body) {
    Request request = new Request();
    request.setBody(body);
    HashMap&lt;String, List&lt;String&gt;&gt; headerMap = new HashMap&lt;&gt;();
    headers.forEach(headerMap::put);
    request.setHeaders(headerMap);
    return request;
}</code></pre><p>BatchRequest is a simple Json object:</p><pre><code class="language-json">{
  &quot;data&quot;: { input data needed to build requests }
  &quot;template&quot;: { batch template to instruct how to build &amp; execute requests }
}</code></pre><p>We also need to implement a simple RequestDispatcher:</p><pre><code class="language-java">@Service
public class RequestDispatcherService implements RequestDispatcher {
    
    @Autowired
    private RestTemplate restTemplate;

    @Override
    public Response dispatch(Request request, JsonProvider jsonProvider, DispatchOptions options) {
        HttpHeaders requestHeaders = new HttpHeaders();
        requestHeaders.putAll(request.getHeaders());
        HttpEntity&lt;Object&gt; httpEntity = request.getBody() != null ?
                new HttpEntity&lt;&gt;(request.getBody(), requestHeaders) 
                : new HttpEntity&lt;&gt;(requestHeaders);
        ResponseEntity responseEntity = restTemplate.exchange(
                &quot;Your service host&quot; + request.getUrl(),
                HttpMethod.resolve(request.getHttpMethod()),
                httpEntity,
                Object.class);
        return buildResponse(responseEntity);
    }

    private Response buildResponse(ResponseEntity responseEntity) {
        Response response = new Response();
        Map&lt;String, List&lt;String&gt;&gt; headers = new HashMap&lt;&gt;();
        responseEntity.getHeaders().forEach(headers::put);
        response.setHeaders(headers);
        response.setStatus(responseEntity.getStatusCodeValue());
        response.setBody(responseEntity.getBody());
        return response;
    }

}</code></pre><p>And it&apos;s done. Now let&apos;s test it.</p><h2 id="a-real-scenario">A real scenario</h2><p>Currently in our system (a Fintech product), we have this scenario: After an user login to our system, we will retrieve all the user&apos;s information, that includes:</p><ul><li>User profile</li><li>User&#x2019;s company profile</li><li>User&#x2019;s wallet information</li></ul><p>Normally we have to call 4 APIs to collect all responses, but only need a subset of data. With Batch API, we only have to make a single call with request body like that:</p><pre><code>{
  &quot;data&quot;: {
    &quot;token&quot;: &quot;user&apos;s token&quot;
  },
  &quot;template&quot;: {
    &quot;requests&quot;: [
      {
        &quot;http_method&quot;: &quot;GET&quot;,
        &quot;url&quot;: &quot;/oauth/payload&quot;,
        &quot;headers&quot;: {
          &quot;Authorization&quot;: &quot;Bearer @{$.original.body.token}@&quot;
        },
        &quot;body&quot;: null,
        &quot;requests&quot;: [
          {
            &quot;http_method&quot;: &quot;POST&quot;,
            &quot;url&quot;: &quot;/report/users&quot;,
            &quot;headers&quot;: {
              &quot;Authorization&quot;: &quot;Bearer @{$.original.body.token}@&quot;
            },
            &quot;body&quot;: {
              &quot;id&quot;: &quot;$.responses[0].body.data.user_id&quot;
            },
            &quot;requests&quot;: [
              {
                &quot;http_method&quot;: &quot;POST&quot;,
                &quot;url&quot;: &quot;/report/wallets&quot;,
                &quot;headers&quot;: {
                  &quot;Authorization&quot;: &quot;Bearer @{$.original.body.token}@&quot;
                },
                &quot;body&quot;: {
                  &quot;user_id&quot;: &quot;$.responses[0].body.data.user_id&quot;
                },
                &quot;requests&quot;: [
                  {
                    &quot;http_method&quot;: &quot;POST&quot;,
                    &quot;url&quot;: &quot;/report/companies&quot;,
                    &quot;headers&quot;: {
                      &quot;Authorization&quot;: &quot;Bearer @{$.original.body.token}@&quot;
                    },
                    &quot;body&quot;: {
                      &quot;id&quot;: &quot;$.responses[1].body.data.users[0].company_id&quot;
                    }
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    &quot;responses&quot;:[
      {
        &quot;body&quot;: {
          &quot;id&quot;: &quot;$.responses[1].body.data.users[0].id&quot;,
          &quot;full_name&quot;: &quot;@{$.responses[1].body.data.users[0].first_name}@ @{$.responses[1].body.data.users[0].last_name}@&quot;,
          &quot;email&quot;: &quot;$.responses[1].body.data.users[0].email&quot;,
          &quot;company&quot;: {
            &quot;id&quot;: &quot;$.responses[3].body.data.companies[0].id&quot;,
            &quot;name&quot;: &quot;$.responses[3].body.data.companies[0].name&quot;
          },
          &quot;wallets&quot;: [
            {
              &quot;id&quot;: &quot;$.id&quot;,
              &quot;balance&quot;: &quot;$.balance&quot;,
              &quot;currency&quot;: &quot;$.currency&quot;,
              &quot;__array_schema&quot;: &quot;$.responses[2].body.data.wallets&quot;
            }
          ]
        }
      }
    ]
  }
}</code></pre><p>I have run a performance test with both ways. Below is the test result when run multi requests:</p><figure class="kg-card kg-image-card"><img src="https://i.imgur.com/BjPOz2b.png" class="kg-image" alt loading="lazy"></figure><p>And next is the test result when run a batch request:</p><figure class="kg-card kg-image-card"><img src="https://i.imgur.com/0U0VhVQ.png" class="kg-image" alt loading="lazy"></figure><p>As you can see, the batch request way only took on average <strong>~141 ms</strong> while the multi requests way took <strong>~369 ms</strong>.</p><p>Next, let&#x2019;s look at the size of response. Below is response size when run multi requests:</p><figure class="kg-card kg-image-card"><img src="https://i.imgur.com/WXvIdb3.png" class="kg-image" alt loading="lazy"></figure><p>And here is the response size when run batch request:</p><figure class="kg-card kg-image-card"><img src="https://i.imgur.com/y9g67oK.png" class="kg-image" alt loading="lazy"></figure><p>By strip out all the unnecessary data from response, we able to reduce the response size 30+ times (9730 &gt; 272)</p><h2 id="conclusion">Conclusion</h2><p>As you can see, with a Batch API, we can archive almost same result as GraphQL without the limit of pre-defined schema.</p>]]></content:encoded></item><item><title><![CDATA[JsonBatch - Journey from zero to full-fledged Batch Engine - part 1]]></title><description><![CDATA[The idea & the first prototype]]></description><link>http://localhost:2368/jsonbatch-the-jouney-part-1/</link><guid isPermaLink="false">637f1ad6a0d66a0001cab8f6</guid><category><![CDATA[Java]]></category><category><![CDATA[JSON]]></category><category><![CDATA[Batch]]></category><dc:creator><![CDATA[Rey Pham]]></dc:creator><pubDate>Tue, 16 Jun 2020 04:15:16 GMT</pubDate><content:encoded><![CDATA[<p>Recently, I have published <a href="https://github.com/rey5137/jsonbatch">JsonBatch</a> - an Engine to run batch requests with JSON based REST APIs. Although it is a small library, I found it quite satisfying to go through all processes, from designing to developing it. So today, I want to share my journey with you.</p><p><strong>I. The idea</strong></p><p>It all started with a requirement for our company product. To support one of our users migrate their own system to our system, we need to provide them an Adapter that will bridge the gap between their APIs to our APIs and maintain it for a while until they finish the migrating process. </p><p>It&apos;s a common requirement, but we want to reuse it somehow, so we don&apos;t have to repeat the same works with other users. At first, we thinking about providing user a way to config what endpoint that their API will route to, and how to map our response back to their response. Quite straight forward, but the reality is not so simple. Due to the different design of 2 systems, their API will mostly have to call multi-requests and then aggregate all responses.</p><p>That is when an idea came to me. What we need is a Batch Engine that can be configured easily &amp; dynamically.</p><p><strong>II. The first prototype</strong></p><p>So for a Batch Engine, it should take a list of requests, execute sequentially, and collect all responses.</p><figure class="kg-card kg-image-card"><img src="https://i.imgur.com/ez5dZuC.png" class="kg-image" alt loading="lazy"></figure><p>The execution logic is simple, but here comes the first challenge: How to build the request body?</p><p>It&apos;s easy if the client can supply all the request bodies, but what if a request body requires data from the response of another request? The Engine needs a way to know how &amp; where to extract data. Because all of the requests &amp; responses will be JSON, so if you want to locate a field, the first answer that came to me is using JsonPath. Fortunately, Java already has a good library <a href="https://github.com/json-path/JsonPath">Jayway&apos;s JsonPath</a> that supports all my needs. </p><p>So now we done with the <strong>How</strong> question, next is the <strong>Where</strong> question. The solution I came up with is building a grand JSON contains all the requests &amp; responses. Something like this:</p><pre><code class="language-json">{
 &quot;original&quot;: {
   &quot;http_method&quot;: &quot;...&quot;,
   &quot;url&quot;: &quot;...&quot;,
   &quot;headers&quot;: {
     &quot;header_1&quot;: [ &quot;...&quot; ],
     &quot;header_2&quot;: [ &quot;...&quot; ],
     ...
   },
   &quot;body&quot;: { ... }
 },
 &quot;requests&quot;: [
     {
       &quot;http_method&quot;: &quot;...&quot;,
       &quot;url&quot;: &quot;...&quot;,
       &quot;headers&quot;: {
         &quot;header_1&quot;: [ &quot;...&quot; ],
         &quot;header_2&quot;: [ &quot;...&quot; ],
         ...
       },
       &quot;body&quot;: { ... }
     },
     ...
 ],
 &quot;responses&quot;: [
     {
       &quot;status&quot;: ...,
       &quot;headers&quot;: {
         &quot;header_1&quot;: [ &quot;...&quot; ],
         &quot;header_2&quot;: [ &quot;...&quot; ],
         ...
       },
       &quot;body&quot;: { ... }
     },
     ...
 ]
}</code></pre><p>With that, only 1 problem left: we need a schema format to instruct the Engine build the actual JSON body. A quick search and I found out JSON Schema. But after some research, I think JSON Schema is more suited to validating than generating, and the schema format has a structure that quite different from actual JSON. So I&apos;m left with designing my own custom schema. </p><p>With some experiments, I came up with a schema that&apos;s simple but good enough. The schema is same as actual JSON but only string field has a specific format. For example:</p><pre><code class="language-json">{
  &quot;field_1&quot;: 1,
  &quot;field_2&quot;: &quot;int $.responses[0].body.field_a&quot;,
  &quot;field_3&quot;: &quot;int[] $.responses[*].body.field_a&quot;
}</code></pre><p>With this schema, the Engine will build a JSON with:</p><ul><li>field_1 = 1</li><li>field_2 is integer, and extract value from JsonPath: <strong>$.responses[0].body.field_a</strong></li><li>field_3 is integer array, and extract value from JsonPath: <strong>$.responses[*].body.field_a</strong></li></ul><p>An actual JSON will look like that:</p><pre><code class="language-json">{
  &quot;field_1&quot;: 1,
  &quot;field_2&quot;: 2,
  &quot;field_3&quot;: [2, 3, 4]
}</code></pre><p>You can see the structure of schema &amp; actual is quite similar.</p><p>Now, after all the pieces came together, it took me about 1 week to code this first prototype. In the next part, I will share how this prototype continues to evolve.</p>]]></content:encoded></item><item><title><![CDATA[Bad chunk header mystery]]></title><description><![CDATA[A case of unwanted Bad chunk header]]></description><link>http://localhost:2368/bad-chunk-header-mystery/</link><guid isPermaLink="false">637f1ad6a0d66a0001cab8f3</guid><category><![CDATA[Java]]></category><category><![CDATA[Springboot]]></category><dc:creator><![CDATA[Rey Pham]]></dc:creator><pubDate>Tue, 10 Mar 2020 08:33:00 GMT</pubDate><content:encoded><![CDATA[<p>Recently, I encounter an interesting issue in my project at work. I&#x2019;m working on many Springboot-based microservices, and sometimes, an exception is thrown after using RestTemplate exchange() method:</p><pre><code class="language-javastacktrace">org.springframework.web.util.NestedServletException: Request processing failed; nested exception is org.springframework.web.client.ResourceAccessException: I/O error on POST request for &#x201C;...&quot;: Bad chunk header: {...}; nested exception is org.apache.http.MalformedChunkCodingException: Bad chunk header: {...} at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014) at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909) at javax.servlet.http.HttpServlet.service(HttpServlet.java:660) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</code></pre><p>Below is the simplified sequence diagram:</p><figure class="kg-card kg-image-card"><img src="https://i.imgur.com/wQl9IuG.png" class="kg-image" alt loading="lazy"></figure><p>After investigating, here is what I found about this issue:</p><ul><li>The exception is thrown after service A received the response from service B.</li><li>The issue only happens when I run some performance test cases that flood service A with requests.</li><li>The issue is pretty consistent, although not at an exact time, but happens most of the times I run test case.</li><li>The interesting thing here is the log from service B &amp; C didn&#x2019;t show anything wrong when this issue happened, indicated that request is succeeded and response is returned. But is it true???</li></ul><p>The exception message is short but still left an important hint: <strong><strong>header</strong></strong>. Did service A receive an inappropriate header, or more correctly, service B sent an unwanted header? How can we know what <strong><strong>header</strong></strong> is wrong?</p><p>Further investigating, I found that service B just forwards request to service C, then forwards the response from service C to service A. Something like this:</p><pre><code class="language-java">public ResponseEntity&lt;?&gt; forwardRequest(@RequestBody Request request) {
    return restTemplate.exchange(url, HttpMethod.POST, request, ...)
}</code></pre><p>If so, did the inappropriate header not come from service B, but from service C instead?</p><p>Luckily, we can insert code to log all the headers of service C response. After adding and re-running test case, here is what I get when the exception occurs:</p><pre><code>Header: [Connection] &gt; [close]
Header: [Content-Type] &gt; [application/json;charset=UTF-8]
Header: [Date] &gt; [DD/mm/yyyy]
Header: [Transfer-Encoding] &gt; [chunked]</code></pre><p>For easier, here is normal response&#x2019;s headers:</p><pre><code>Header: [Content-Type] &gt; [application/json;charset=UTF-8]
Header: [Date] &gt; [DD/mm/yyyy]
Header: [Transfer-Encoding] &gt; [chunked]</code></pre><p>Finally, we can see the culprit. It is the header <strong><strong>Connection: close</strong></strong> that service C returned and service B blindly returned to service A.</p><p>But what does <strong><strong>Connection: close</strong></strong> mean? And how it is included in the service C response?</p><p>From <a href="https://tools.ietf.org/html/rfc2616#section-14.10" rel="noopener nofollow"><em><em>RFC 2616, Section 14.10</em></em></a> , <strong><strong>Connection: close</strong></strong> is included to signal that the connection will be closed after completion of the response. Normally, connection with <strong><strong>keepAlive</strong></strong> property will not be closed by the server so the client can keep using it for another request. But tomcat has a <strong><strong>max-keepalive-timeout</strong></strong> setting, that will close connection that reaches a certain keepAlive time. And that is when the server will include <strong><strong>Connection: close</strong></strong> header.</p><h1 id="conclusion">Conclusion</h1><p>Now we know that blindly forwarding responses without filtering out headers is a bad practice. In case you don&#x2019;t care about the header, just extract and return only the response body is enough.</p>]]></content:encoded></item><item><title><![CDATA[How I organize Android project structure]]></title><description><![CDATA[Let me show you my current Android project structure]]></description><link>http://localhost:2368/how-i-organize-android-project-structure/</link><guid isPermaLink="false">637f1ad6a0d66a0001cab8f2</guid><category><![CDATA[Android]]></category><category><![CDATA[Java]]></category><category><![CDATA[Gradle]]></category><dc:creator><![CDATA[Rey Pham]]></dc:creator><pubDate>Fri, 10 Jun 2016 08:23:00 GMT</pubDate><content:encoded><![CDATA[<p>In my recent project <a href="https://play.google.com/store/apps/details?id=com.rey.unitconverter" rel="noopener nofollow"><strong><strong>Material Unit Converter</strong></strong></a> , I have a chance to try out various interesting things like RxJava, MVP, Clean Architecture, &#x2026;</p><p>I will have a post about my experiences with all those trending in other day, but today I want to show you my Android project structure that helps me a lot in managing my codebase.</p><p><strong><strong>I. Sensitive data</strong></strong></p><p>There are always some sensitive data in your project. Whether it be keystore&#x2019;s password or third-party API secret key, you want to keep it out of version control system. You can put it in <em><em>gradle.properties</em></em> file of your project like below:</p><pre><code>KEYSTORE_PASSWORD=&lt;your keystore&apos;s password&gt;
KEYSTORE_FILE=&lt;your keystore file&gt;
KEYSTORE_ALIAS=&lt;your keystore&apos;s alias&gt;</code></pre><p>Later you can use those properties in <em><em>build.gradle</em></em> file:</p><pre><code>signingConfigs {
    release {
        storeFile file(KEYSTORE_FILE)
        storePassword KEYSTORE_PASSWORD
        keyAlias KEYSTORE_ALIAS
        keyPassword KEYSTORE_PASSWORD
    }
}</code></pre><p>Of course, you need to make sure not committing this file to VCS. But if you are lazy like me, you can put all those properties to <em><em>gradle.properties</em></em> file in <strong><strong>GRADLE_HOME</strong></strong> folder.</p><p><strong><strong>II.</strong> <strong>Dependencies</strong></strong></p><p>To manage all my project&#x2019;s dependencies, I put it in a <em><em>library.gradle</em></em> file:</p><pre><code>ext.version = [
    support          : &quot;23.2.1&quot;,
    rxjava           : &quot;1.1.0&quot;,
    rxandroid        : &quot;1.1.0&quot;,
       
    // rest of libraries
]

def version = ext.version;

ext.library = [
    support_compat   : 
&quot;com.android.support:appcompat-v7:${version.support}&quot;,
    support_design   : &quot;com.android.support:design:${version.support}&quot;,
    rxjava           :
&quot;io.reactivex:rxjava:${version.rxjava}&quot;,
    rxandroid        :
&quot;io.reactivex:rxandroid:${version.rxandroid}&quot;,
    // rest of libraries
]</code></pre><p>The file is stored in <em><em>buildsystem</em></em> folder of the project.</p><figure class="kg-card kg-image-card"><img src="https://i.imgur.com/WBT9k7F.jpg" class="kg-image" alt loading="lazy"></figure><p>Then in <em><em>build.gradle</em></em> file:</p><pre><code>apply from: &quot;$rootProject.projectDir/buildsystem/library.gradle&quot;
def library = ext.library;
dependencies {
    compile                 fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])
    compile                 &quot;${library.support_compat}&quot;
    compile                 &quot;${library.support_design}&quot;
    compile                 &quot;${library.rxjava}&quot;
    compile                 &quot;${library.rxandroid}&quot;
    // rest of dependencies
}</code></pre><p><strong><strong>III. Configuration</strong></strong></p><p>Like dependencies, I use<em><em> config.gradle</em></em> file to store all project configurations.</p><pre><code>ext.configuration = [
        applicationId               : &lt;your app package name&gt;,
        versionMajor                : 1,
        versionMinor                : 0,
        versionPatch                : 2,
        versionClassifier           : &quot;&quot;,
        minimumSdkVersion           : 14,
        compileSdkVersion           : 23,
        targetSdkVersion            : 23,
        buildToolsVersion           : &quot;23.0.2&quot;
]

def configuration = ext.configuration;

ext.buildVersionCode = {
    return configuration.minimumSdkVersion * 10000000 + configuration.versionMajor * 10000 + configuration.versionMinor * 100 + configuration.versionPatch
}

ext.buildVersionName = {
    String versionName = ext.buildVersionNameWithoutClassifier();
    if (configuration.versionClassifier != null &amp;&amp; !configuration.versionClassifier.isEmpty()) {
        versionName = versionName + &quot;-&quot; + configuration.versionClassifier
    }
    return versionName;
}</code></pre><p>You can see that I create <strong><strong>buildVersionCode</strong></strong> function to generate version code with first 2 digits for minimum SDK version, 1 digit for reverse, then follow with major, minor and patch number, each has 2 digits. For version name, I use format &#x201C; major.minor.patch-Classifier&#x201D;.</p><p>Now we can use it in <em><em>build.gradle</em></em> file:</p><pre><code>apply from: &quot;$rootProject.projectDir/buildsystem/config.gradle&quot;
def configuration = ext.configuration;

android {
    compileSdkVersion configuration.compileSdkVersion
    buildToolsVersion configuration.buildToolsVersion

    defaultConfig {
        applicationId configuration.applicationId
        minSdkVersion configuration.minimumSdkVersion
        targetSdkVersion configuration.targetSdkVersion
        versionCode buildVersionCode()
        versionName buildVersionName()
    }
}</code></pre><p><strong><strong>IV. Source code packages</strong></strong></p><p>Here is my packages structure:</p><figure class="kg-card kg-image-card"><img src="https://i.imgur.com/FroUjyG.png" class="kg-image" alt loading="lazy"></figure><p>Each <strong><strong>data, domain, repository</strong></strong> package contains classes of a Clean Architecture&#x2019;s layer.</p><p><strong><strong>common </strong></strong>package contains some utility classes. <strong><strong>dependency </strong></strong>package contains classes that are used to provide dependency injection (Dagger).</p><p>Each app&#x2019;s feature will have it own child package in <strong><strong>feature </strong></strong>package. It should be the presentation layer of Clean Architecture.</p><p>And the last, <strong><strong>unitconverter </strong></strong>package contains classes that depend on Android framework like <strong><strong>Application</strong></strong>, <strong><strong>Activity</strong></strong>, <strong><strong>View</strong></strong>.</p><p><strong><strong>V. Test source folder</strong></strong></p><p>I separate test codes to multi-source folders like below:</p><pre><code>android {
...
    sourceSets {
        // Common code for all tests
        test.java.srcDir &apos;src/commonTests/java&apos;
        androidTest.java.srcDir &apos;src/commonTests/java&apos;

        // Unit tests
        test.java.srcDir &apos;src/unitTests/java&apos;

        // Integration tests
        test.java.srcDir &apos;src/integrationTests/java&apos;

        // Unit tests for debug build variant
        testDebug.java.srcDir &apos;src/debugUnitTests/java&apos;

        // Unit tests for release build variant
        testRelease.java.srcDir &apos;src/releaseUnitTests/java&apos;

        // Functional tests
        androidTest.java.srcDir &apos;src/functionalTests/java&apos;
    }
...
}</code></pre><p>You can see we have<strong><strong> commonTests</strong></strong> source folder for any common class used in test. Each type of test is stored in different source folder, and each build variant also has it own test source folder.</p><p><strong><strong>VI. Conclusion</strong></strong></p><p>With this structure, my project has become more manageable. In future, I will update this post if I find out way to improve it.</p>]]></content:encoded></item><item><title><![CDATA[Let’s drill a hole in your view]]></title><description><![CDATA[How to make overlay tutorial]]></description><link>http://localhost:2368/lets-drill-a-hole-in-your-view/</link><guid isPermaLink="false">637f1ad6a0d66a0001cab8f1</guid><category><![CDATA[Android]]></category><category><![CDATA[Java]]></category><dc:creator><![CDATA[Rey Pham]]></dc:creator><pubDate>Thu, 03 Mar 2016 08:16:00 GMT</pubDate><media:content url="https://i.imgur.com/UsCF6le.jpg" medium="image"/><content:encoded><![CDATA[<img src="https://i.imgur.com/UsCF6le.jpg" alt="Let&#x2019;s drill a hole in your view"><p>Sometimes you can see this kind of tutorial, that is called overlay tutorial. If you want to use it in your app, there&#x2019;re already some libraries available like <a href="https://github.com/deano2390/MaterialShowcaseView" rel="noopener nofollow"><strong><strong>MaterialShowCase</strong></strong></a><strong><strong> </strong></strong>or <a href="https://github.com/worker8/TourGuide" rel="noopener nofollow"><strong><strong>TourGuide</strong></strong></a>. But have you ever wonder how it can be done, or exactly how to draw an overlay with a hole? In this post, I will introduce to you 3 methods to achieve that.</p><h1 id="i-bitmap">I. Bitmap</h1><p>Using a bitmap may be the way that most people will come up with. All those libraries I mentioned above are using this method. Basically, you create a bitmap with same size as your screen, fill it with color, then erase a region of its.</p><p>OK, here is the code:</p><pre><code class="language-java">//Create a bitmap with same size as screen.
mBitmap = Bitmap.createBitmap(mWidth, mHeight, Bitmap.Config.ARGB_8888);
mBitmap.eraseColor(Color.TRANSPARENT);
//Fill it with color
Canvas c = new Canvas(mBitmap);
c.drawColor(mBackgroundColor);
Paint p = new Paint(Paint.ANTI_ALIAS_FLAG);
p.setStyle(Paint.Style.FILL);
p.setColor(0xFFFFFFFF);
p.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));
//Erase color
c.drawCircle(mX, mY, mHoleRadius, p);</code></pre><p>It&#x2019;s quite simple. The only magic here is calling <em><em>setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR)); </em></em>on your Paint object so it can erase color. Now you can draw this Bitmap into your canvas:</p><pre><code class="language-java">canvas.drawBitmap(mBitmap, 0, 0, null);</code></pre><p>The drawback of this method is the bitmap may take up a large of memory. If you don&#x2019;t use it carefully, you may soon see some <strong><strong>OutOfMemory </strong></strong>crashes, especially on low devices.</p><h1 id="ii-path">II. Path</h1><p>You can use <strong><strong>Path </strong></strong>to create a complex shape, in this case is a rectangle with a hole.</p><pre><code class="language-java">mPath = new Path();
mPath.setFillType(Path.FillType.WINDING);
mPath.addRect(0, 0, mWidth, mHeight, Path.Direction.CW);
mPath.addCircle(mX, mY, mHoleRadius, Path.Direction.CCW);</code></pre><p>Now, simply create a <strong><strong>Paint </strong></strong>object and draw the path:</p><pre><code class="language-java">Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
mPaint.setStyle(Paint.Style.FILL);
mPaint.setColor(mBackgroundColor);
canvas.drawPath(mPath, mPaint);</code></pre><p>The drawback is <em><em>drawPath() </em></em>can be slow because <strong><strong>Path </strong></strong>are always rendered using the CPU.</p><h1 id="iii-gradient">III. Gradient</h1><p>It sound weird but you can totally use gradient with some tricky setting to achieve the effect.</p><p>First, create a <strong><strong>RadialGradient </strong></strong>shader:</p><pre><code class="language-java">RadialGradient mShader = new RadialGradient(mX, mY, mHoleRadius,new int[]{Color.TRANSPARENT, Color.TRANSPARENT, mBackgroundColor}, new float[]{0f, 0.99f, 1f}, Shader.TileMode.CLAMP);</code></pre><p>Now, set this shader to <strong><strong>Paint </strong></strong>object and simply draw a rectangle:</p><pre><code class="language-java">Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
mPaint.setStyle(Paint.Style.FILL);
mPaint.setShader(mShader);
canvas.drawRect(0, 0, mWidth, mHeight, mPaint);</code></pre><p>The drawback is the edge of the hole is not sharp as using <strong><strong>Bitmap </strong></strong>or <strong><strong>Path</strong></strong>, but it isn&#x2019;t a big different.</p><h1 id="iv-conclusion">IV. Conclusion</h1><p>Each of those methods I mentioned has its own drawback. Feel free to choose ones you familiar with. As for me, I&#x2019;ll stick with Gradient method.</p><p>The source code is available on <a href="https://github.com/rey5137/tutorials/tree/draw_hole_in_view" rel="noopener nofollow">Github</a>.</p>]]></content:encoded></item><item><title><![CDATA[Custom Drawable — Part 3]]></title><description><![CDATA[How to create an animated drawable.]]></description><link>http://localhost:2368/custom-drawable-part-3/</link><guid isPermaLink="false">637f1ad6a0d66a0001cab8f0</guid><category><![CDATA[Android]]></category><category><![CDATA[Java]]></category><dc:creator><![CDATA[Rey Pham]]></dc:creator><pubDate>Sat, 27 Feb 2016 08:08:00 GMT</pubDate><content:encoded><![CDATA[<p>In the last part of this series, we will make the drawable animated between states. Here is the result we want:</p><figure class="kg-card kg-image-card"><img src="https://i.imgur.com/jKhLulN.gif" class="kg-image" alt loading="lazy"></figure><p>Ok, let&#x2019;s do it.</p><h1 id="animatedstateborderdrawable">AnimatedStateBorderDrawable</h1><p>As usual, we need to make some changes on <strong><strong>StateBorderDrawable </strong></strong>class.</p><ul><li>First, we add a new <strong><strong>duration </strong></strong>parameter to constructor method:</li></ul><pre><code class="language-java">public class AnimatedStateBorderDrawable extends Drawable {

    private boolean mRunning = false;
    private long mStartTime;
    private int mAnimDuration;

    Paint mPaint;
    ColorStateList mColorStateList;
    int mPrevColor;
    int mMiddleColor;
    int mCurColor;
    int mBorderWidth;
    int mBorderRadius;

    RectF mRect;
    Path mPath;

    public BorderDrawable(ColorStateList colorStateList, int borderWidth, int borderRadius, int duration){
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        mPaint.setStyle(Paint.Style.FILL);

        mPath = new Path();
        mPath.setFillType(Path.FillType.EVEN_ODD);

        mRect = new RectF();

        mColorStateList = colorStateList;
        mCurColor = mColorStateList.getDefaultColor();
        mPrevColor = mCurColor;
        mBorderWidth = borderWidth;
        mBorderRadius = borderRadius;
        mAnimDuration = duration;
    }
}</code></pre><p>You can see that I added some new member variable like <strong><strong>mPrevColor</strong></strong>, <strong><strong>mCurColor</strong></strong>, <strong><strong>mMiddeColor</strong></strong>. Because we will animate the color between 2 states, so we need to know the color of previous and current state. Some variable like <strong><strong>mRunning</strong></strong>, <strong><strong>mStartTime </strong></strong>also needed for storing animation&#x2019;s data.</p><ul><li>Next, we have to implement<strong><strong> android.graphics.drawable.Animatable</strong></strong> interface. There are 3 methods:</li></ul><pre><code class="language-java">@Override
public boolean isRunning() {
    return mRunning;
}

@Override
public void start() {
    resetAnimation();
    scheduleSelf(mUpdater, SystemClock.uptimeMillis() + FRAME_DURATION);
    invalidateSelf();
}

@Override
public void stop() {
    mRunning = false;
    unscheduleSelf(mUpdater);
    invalidateSelf();
}</code></pre><p><strong><strong>isRunning()</strong></strong> is pretty forward, so let&#x2019;s talk about <strong><strong>start() </strong></strong>method. When we call <strong><strong>start()</strong></strong> method to start running the animation, first we have to call <strong><strong>resetAnimation()</strong></strong> to reset all animation&#x2019;s data:</p><pre><code class="language-java">private void resetAnimation(){
    mStartTime = SystemClock.uptimeMillis();
    mMiddleColor = mPrevColor;
}</code></pre><p>You will see that there are 2 variables need to be updated: <strong><strong>mStartTime </strong></strong>for animation start running time, and <strong><strong>mMiddleColor </strong></strong>for color will be drawn when animation running. Then, we will schedule a <strong><strong>Runnable </strong></strong>will be run after a specific duration to update animation&#x2019;s progress and invalidate drawable:</p><pre><code class="language-java">private final Runnable mUpdater = new Runnable() {

    @Override
    public void run() {
        update();
    }

};

private void update(){
    long curTime = SystemClock.uptimeMillis();
    float progress = Math.min(1f, (float) (curTime - mStartTime) / mAnimDuration);
    mMiddleColor = getMiddleColor(mPrevColor, mCurColor, progress);

    if(progress == 1f)
        mRunning = false;

    if(isRunning())
        scheduleSelf(mUpdater, SystemClock.uptimeMillis() + FRAME_DURATION);

    invalidateSelf();
}</code></pre><p>In the <em><em>update()</em></em> method, we will calculate the <strong><strong>mMiddleColor </strong></strong>based on the animation&#x2019;s progress and the color of 2 states. Then we check if the animation is completed to continue schedule <strong><strong>mUpdater </strong></strong>or not.</p><ul><li>Next, we update <em><em>onStateChange(int[])</em></em> and <em><em>drawn(Canvas)</em></em> methods:</li></ul><pre><code class="language-java">@Override
protected boolean onStateChange(int[] state) {
    int color = mColorStateList.getColorForState(state, mCurColor);

    if(mCurColor != color){
        if(mAnimDuration &gt; 0){
            mPrevColor = isRunning() ? mMiddleColor : mCurColor;
            mCurColor = color;
            start();
        }
        else{
            mPrevColor = color;
            mCurColor = color;
            invalidateSelf();
        }
         return true;
    }

    return false;
}

@Override
public void draw(Canvas canvas) {
    mPaint.setColor(isRunning() ? mMiddleColor : mCurColor);
    canvas.drawPath(mPath, mPaint);
}</code></pre><ul><li>And we also override<em><em> jumpToCurrentState()</em></em> and <em><em>scheduleSelf(Runnable, long)</em></em> methods:</li></ul><pre><code class="language-java">@Override
public void jumpToCurrentState() {
    super.jumpToCurrentState();
    stop();
}

@Override
public void scheduleSelf(Runnable what, long when) {
    mRunning = true;
    super.scheduleSelf(what, when);
}</code></pre><p><em><em>jumpToCurrentState() </em></em>method will be called when the view want to skip all the drawable&#x2019;s animation, so we will call <em><em>stop()</em></em> method to stop animation if it&#x2019;s running.</p><h1 id="animatedstateborderimageview">AnimatedStateBorderImageView</h1><p>We just have to change some few point in the <strong><strong>StateBorderImageView </strong></strong>class.</p><ul><li>First is the <em><em>init()</em></em> method. Change from <strong><strong>StateBorderDrawable </strong></strong>to <strong><strong>AnimatedStateBorderDrawable</strong></strong>:</li></ul><pre><code class="language-java">mBorder = new AnimatedStateBorderDrawable(colorStateList, 
        getPaddingLeft(), 
        getPaddingLeft() / 2, 
        context.getResources().getInteger(android.R.integer.config_mediumAnimTime));</code></pre><ul><li>Next, we need to override <em><em>jumpDrawablesToCurrentState() </em></em>method to notify drawable when the view want to skip all animations.</li></ul><pre><code class="language-java">@Override
public void jumpDrawablesToCurrentState() {
    super.jumpDrawablesToCurrentState();
    mBorder.jumpToCurrentState();
}</code></pre><ul><li>That&#x2019;s it. Now we can add this <strong><strong>AnimatedStateBorderImageView </strong></strong>to XML:</li></ul><pre><code class="language-xml">&lt;com.rey.tutorial.widget.AnimatedStateBorderImageView
    android:layout_width=&quot;96dp&quot;
    android:layout_height=&quot;96dp&quot;
    android:src=&quot;@drawable/avatar&quot;
    android:scaleType=&quot;centerCrop&quot;
    android:padding=&quot;8dp&quot;/&gt;</code></pre><p>Let&#x2019;s run and see the result.</p><p>That is the last of this tutorial series. Although the code is simple, but now you know the basic of implementing a fully animated drawable.</p><p>The source code is available on <a href="https://github.com/rey5137/tutorials/tree/add_drawable_to_view" rel="noopener nofollow">Github</a>.</p>]]></content:encoded></item><item><title><![CDATA[Custom Drawable — Part 2]]></title><description><![CDATA[How to create a state-based Drawable]]></description><link>http://localhost:2368/custom-drawable-part-2/</link><guid isPermaLink="false">637f1ad6a0d66a0001cab8ef</guid><category><![CDATA[Android]]></category><category><![CDATA[Java]]></category><dc:creator><![CDATA[Rey Pham]]></dc:creator><pubDate>Sat, 27 Feb 2016 07:37:00 GMT</pubDate><content:encoded><![CDATA[<p>In <a href="https://rey5137.com/custom-drawable-part-1/">first part</a>, I have shown you how to create a simple drawable and add it to a view. Now, we will try to customize it. Here is the result:</p><figure class="kg-card kg-image-card"><img src="https://i.imgur.com/TScGnC2.gif" class="kg-image" alt loading="lazy"></figure><p>You can see that the border&#x2019;s color changed when we click on the view. Ok, let&#x2019;s do it.</p><h1 id="stateborderdrawable">StateBorderDrawable</h1><p>We need to make some changes on <strong><strong>BorderDrawable </strong></strong>class.</p><ul><li>First, we change the int color parameter to <strong><strong>ColorStateList </strong></strong>parameter.</li></ul><pre><code class="language-java">public class StateBorderDrawable extends Drawable {

    Paint mPaint;
    ColorStateList mColorStateList;
    int mColor;
    int mBorderWidth;
    int mBorderRadius;

    RectF mRect;
    Path mPath;

    public BorderDrawable(ColorStateList colorStateList, int borderWidth, int borderRadius){
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        mPaint.setStyle(Paint.Style.FILL);

        mPath = new Path();
        mPath.setFillType(Path.FillType.EVEN_ODD);

        mRect = new RectF();

        mColorStateList = colorStateList;
        mColor = mColorStateList.getDefaultColor();
        mBorderWidth = borderWidth;
        mBorderRadius = borderRadius;
    }
}</code></pre><ul><li>Override<em><em> isStateful()</em></em> method to return true to indicate that this Drawable want to be notified when view&#x2019; state changed.</li></ul><pre><code class="language-java">@Override
public boolean isStateful() {
    return true;
}</code></pre><ul><li>We also have to override <em><em>onStateChange(int)</em></em> method to handle state changed event.</li></ul><pre><code class="language-java">@Override
protected boolean onStateChange(int[] state) {
    int color = mColorStateList.getColorForState(state, mColor);
    if(mColor != color){
        mColor = color;
        invalidateSelf();
        return true;
    }

    return false;
}</code></pre><p>You can see in the code that we retrieve a color based on the current state of view. Then we check if the new color is different with current color. If yes, we update color and call <em><em>invalidateSelf()</em></em> method to request a re-drawn.</p><h1 id="stateborderimageview">StateBorderImageView</h1><p>We also need to modify the <strong><strong>BorderImageView </strong></strong>class.</p><ul><li>First is the<em><em> init()</em></em> method.</li></ul><pre><code class="language-java">private void init(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes){
    setWillNotDraw(false);
    int[][] states = new int[][]{
            {-android.R.attr.state_pressed},
            {android.R.attr.state_pressed}
    };
    int[] colors = new int[]{
            context.getResources().getColor(R.color.primary),
            context.getResources().getColor(R.color.accent)
    };
    ColorStateList colorStateList = new ColorStateList(states, colors);

    mBorder = new StateBorderDrawable(colorStateList, getPaddingLeft(), getPaddingLeft() / 2);
    mBorder.setCallback(this);
}</code></pre><p>To keep it simple, I create a <strong><strong>ColorStateList </strong></strong>with only 2 states: <strong><strong>not pressed</strong></strong> and <strong><strong>pressed</strong></strong>. For dynamically, you can declare a custom color attribute for your view and read the <strong><strong>ColorStateList </strong></strong>value from it.<br>Another different is we have to call <em><em>setCallback(Callback)</em></em> method on drawable object so when drawable is invalidated, it can request the view to re-drawn.</p><ul><li>Next, we need to override <em><em>drawableStateChanged() </em></em>method to notify drawable when state&#x2019;s changed.</li></ul><pre><code class="language-java">@Override
protected void drawableStateChanged() {
    super.drawableStateChanged();
    mBorder.setState(getDrawableState());
}</code></pre><ul><li>And <em><em>verifyDrawable(Drawable)</em></em>.</li></ul><pre><code class="language-java">@Override
protected boolean verifyDrawable(Drawable dr) {
    return super.verifyDrawable(dr) || dr == mBorder;
}</code></pre><p>When a drawable request the view to re-drawn (via <em><em>Callback#invalidateDrawable(Drawable)</em></em> method), the view will check if the drawable belongs to it before invalide itself.</p><ul><li>Okay. Now we can add this <strong><strong>StateBorderImageView </strong></strong>to XML:</li></ul><pre><code class="language-xml">&lt;com.rey.tutorial.widget.StateBorderImageView
    android:layout_width=&quot;96dp&quot;
    android:layout_height=&quot;96dp&quot;
    android:src=&quot;@drawable/avatar&quot;
    android:scaleType=&quot;centerCrop&quot;
    android:padding=&quot;8dp&quot;/&gt;</code></pre><p>Let&#x2019;s run and see the result.</p><p>Now you know how to create a state-based drawable. In the <a href="https://rey5137.com/custom-drawable-part-3/">last part</a>, we will go to next level and make it animate between states.</p><p>The source code is available on <a href="https://github.com/rey5137/tutorials/tree/add_drawable_to_view" rel="noopener nofollow">Github</a>.</p>]]></content:encoded></item><item><title><![CDATA[Custom Drawable — Part 1]]></title><description><![CDATA[How to create your own custom Drawable]]></description><link>http://localhost:2368/custom-drawable-part-1/</link><guid isPermaLink="false">637f1ad6a0d66a0001cab8ed</guid><category><![CDATA[Android]]></category><category><![CDATA[Java]]></category><dc:creator><![CDATA[Rey Pham]]></dc:creator><pubDate>Fri, 26 Feb 2016 08:05:00 GMT</pubDate><content:encoded><![CDATA[<p>Sometimes you really want to apply some specific visual to your app, and if you look for answer on the web, most of them is <strong><strong>write your own Drawable class</strong></strong>.<br>So what is <strong><strong>Drawable</strong></strong>? Here is class definition: A <strong><strong>Drawable</strong></strong> is a general abstraction for &#x201C;something that can be drawn&#x201D;.<br>Ok, we have <strong><strong>Drawable</strong></strong> class. But how we can use it, or how we can add it to a view? And that what this tutorial is for.</p><p>Now, let&#x2019;s try to create a border for <strong><strong>ImageView</strong></strong>. Here is the result we want:</p><figure class="kg-card kg-image-card"><img src="https://i.imgur.com/o6gs8zW.jpg" class="kg-image" alt loading="lazy"></figure><h1 id="borderdrawable"><strong>BorderDrawable</strong></h1><ul><li>First, we create a class extends from <strong><strong>Drawable</strong></strong>. We also create a constructor to pass all needed attributes.</li></ul><pre><code class="language-Java">public class BorderDrawable extends Drawable {

    Paint mPaint;
    int mColor;
    int mBorderWidth;
    int mBorderRadius;

    RectF mRect;
    Path mPath;

    public BorderDrawable(int color, int borderWidth, int borderRadius){
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        mPaint.setStyle(Paint.Style.FILL);

        mPath = new Path();
        mPath.setFillType(Path.FillType.EVEN_ODD);

        mRect = new RectF();

        mColor = color;
        mBorderWidth = borderWidth;
        mBorderRadius = borderRadius;
    }
}</code></pre><ul><li>Override<em><em> onBoundsChange(Rect) </em></em>method to calculate the Path we will draw later in <em><em>draw(Canvas)</em></em>.</li></ul><pre><code class="language-Java">@Override
protected void onBoundsChange(Rect bounds) {
    mPath.reset();

    mPath.addRect(bounds.left, bounds.top, bounds.right, bounds.bottom, Path.Direction.CW);
    mRect.set(bounds.left + mBorderWidth, bounds.top + mBorderWidth, bounds.right - mBorderWidth, bounds.bottom - mBorderWidth);
    mPath.addRoundRect(mRect, mBorderRadius, mBorderRadius, Path.Direction.CW);
}</code></pre><ul><li>We also need implement some abstract methods.</li></ul><pre><code class="language-Java">@Override
public void draw(Canvas canvas) {
    mPaint.setColor(mColor);
    canvas.drawPath(mPath, mPaint);
}

@Override
public void setAlpha(int alpha) {
    mPaint.setAlpha(alpha);
}

@Override
public void setColorFilter(ColorFilter cf) {
    mPaint.setColorFilter(cf);
}

@Override
public int getOpacity() {
    return PixelFormat.TRANSLUCENT;
}</code></pre><h1 id="borderimageview">BorderImageView</h1><ul><li>Create a class extends from <strong><strong>ImageView </strong></strong>class.</li></ul><pre><code class="language-Java">public class BorderImageView extends ImageView{

    BorderDrawable mBorder;

    public BorderImageView(Context context) {
        super(context);

        init(context, null, 0, 0);
    }

    public BorderImageView(Context context, AttributeSet attrs) {
        super(context, attrs);

        init(context, attrs, 0, 0);
    }

	//another constructors ...

    private void init(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes){
        setWillNotDraw(false);
        mBorder = new BorderDrawable(context.getResources().getColor(R.color.primary), getPaddingLeft(), getPaddingLeft() / 2);
    }
	
}</code></pre><p>In <em><em>init()</em></em> method, we have to call <em><em>setWillNotDraw(false)</em></em> so the view will call <em><em>onDraw(canvas)</em></em> later, or else it will skip. You also see that I use the padding value of ImageView as the border&#x2019;s width.</p><ul><li>Next, we need override <em><em>onSizeChanged(int, int, int, int)</em></em> method to set the bound of drawable.</li></ul><pre><code class="language-Java">@Override
protected void onSizeChanged(int w, int h, int oldw, int oldh) {
    super.onSizeChanged(w, h, oldw, oldh);
    mBorder.setBounds(0, 0, w, h);
}</code></pre><ul><li>And <em><em>onDraw(canvas) </em></em>to make a call to the <em><em>draw(Canvas) </em></em>method of drawable.</li></ul><pre><code class="language-Java">@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    mBorder.draw(canvas);
}</code></pre><ul><li>That&#x2019;s it. Now we can add this <strong><strong>BorderImageView </strong></strong>to XML:</li></ul><pre><code class="language-XML">&lt;com.rey.tutorial.widget.BorderImageView
    android:layout_width=&quot;96dp&quot;
    android:layout_height=&quot;96dp&quot;
    android:src=&quot;@drawable/avatar&quot;
    android:scaleType=&quot;centerCrop&quot;
    android:padding=&quot;8dp&quot;/&gt;</code></pre><p>Although you can extend <strong><strong>ImageView </strong></strong>class and draw the border directly in <em><em>onDraw(Canvas)</em></em> method, using <strong><strong>Drawable </strong></strong>is more reusable. In <a href="http://localhost:2368/custom-drawable-part-2/">second part</a>, I will show you how to create a state-based drawable.</p><p>The source code is available on <a href="https://github.com/rey5137/tutorials/tree/add_drawable_to_view" rel="noopener nofollow">Github</a>.</p>]]></content:encoded></item></channel></rss>